---
layout: post
title: "Powershell: Everything you wanted to know about exception handling"
date: 2017-03-26
tags: [PowerShell,Exception Handling,Basic]
---

Error handling is just part of live when it comes to writing code. We can check and validate conditions on expected behavior. When the unexpected happens, we turn to exception handling. You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.

# Index

# Basic terminology
If you have not worked with exceptions before, there are some specific terms that you need to know.

## Exception

An Exception is an event that is generally created when normal error handling can not deal with the issue. Trying to divide a number by zero or open a file that does not exist are examples of something that will create an exception.

## Throw and Catch

When an exception event happens, we call that throwing an exception. To handle a thrown exception, you need to catch it. If an exception is thrown and it is not caught by something, the program will crash.

## Call stack

The call stack is the list of functions that have called each other. When a function is called, it gets added to the stack. When the function exits or returns, it will be removed from the stack.

When an exception is thrown, that call stack is checked in order for a catch.

## Terminating and non-terminating errors

An exception is a terminating error. A thrown error will either be caught or it will exit the current execution. A non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.

I point this out because `Write-Error` and other non-terminating errors will not trigger the catch script to execute.

# Basic commands

Here is a quick overview of the basic exception handling syntax used in PowerShell.

## Throw

We can also throw an exception with the `throw` keyword.

    function Do-Something
    {
        throw "Bad thing happened"
    }

This creates an exception that is a terminating error. It will either exit the script or be handled by a `catch` in a calling function.

## Try/Catch

The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it. Here is a quick sample.

    try
    {
        Do-Something
    }
    catch
    {
        Write-Output "Something threw an exception"
    }

The `catch` script only runs if there is an exception. So if the `try` executes correctly, then it will skip over the catch.

## Try/Finally

Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not. A `finally` script does exactly that. 

Take a look at this example:

    $command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
    $command.Connection.Open()
    $command.ExecuteNonQuery()
    $command.Connection.Close()

Any time you open or connect to a resource, you should close it. If the `ExecuteNonQuery()` throws an exception, the connection will not get closed correctly.

    $command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
    try
    {         
        $command.Connection.Open()
        $command.ExecuteNonQuery()
    }
    finally
    {
        $command.Connection.Close()
    }

In this example, the connection will get closed if there is an error. It will also get closed if there is no error. The `finally` script will run every time.

Because you are not catching the exception, it will still get thrown up the call stack.

## Try/Catch/Finally

It is perfectly valid to use `catch` and `finally` together. Most of the time you will use one or the other, but there are scenarios where you will use both.

